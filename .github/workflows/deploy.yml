name: 🚀 Deploy - Déploiement Application AQI

on:
  push:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'pipelines/**'
      - 'requirements.txt'
      - 'Dockerfile'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement de déploiement'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Forcer le déploiement'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.9'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/aqi-predictor

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
    - name: 🔽 Checkout du code
      uses: actions/checkout@v4
    
    - name: 🐍 Configuration Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: 📦 Installation des dépendances
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov flake8 black isort
    
    - name: 🧹 Vérification du style de code
      run: |
        echo "🧹 Vérification du formatage avec Black..."
        black --check --diff . || echo "⚠️ Black: des fichiers nécessitent un formatage"
        
        echo "📦 Vérification des imports avec isort..."
        isort --check-only --diff . || echo "⚠️ isort: des imports nécessitent un tri"
        
        echo "🔍 Analyse statique avec flake8..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: 🧪 Tests unitaires
      run: |
        echo "🧪 Exécution des tests unitaires..."
        python -c "
        import sys
        import os
        
        # Ajout du chemin pour les imports
        sys.path.append('.')
        
        # Tests simples pour vérifier les imports et fonctions principales
        try:
            from app.utils.aqi_utils import AQIUtils, APIHelper, DataValidator
            from app.utils.plotting import AQIPlotter, DashboardComponents
            
            print('✅ Import des utilitaires: OK')
            
            # Test des fonctions utilitaires
            aqi_category = AQIUtils.get_aqi_category(75)
            assert aqi_category == 'Modéré', f'Erreur catégorie AQI: {aqi_category}'
            
            aqi_color = AQIUtils.get_aqi_color(75)
            assert aqi_color == '#FFFF00', f'Erreur couleur AQI: {aqi_color}'
            
            print('✅ Tests AQI utils: OK')
            
            # Test de validation des données
            test_data = {'pm25': 25, 'pm10': 40, 'o3': 30, 'no2': 15}
            valid, errors = DataValidator.validate_pollutant_data(test_data)
            assert valid, f'Erreur validation: {errors}'
            
            print('✅ Tests validation données: OK')
            
            print('🎉 Tous les tests passent!')
            
        except Exception as e:
            print(f'❌ Erreur dans les tests: {e}')
            sys.exit(1)
        "
    
    - name: 🔒 Tests de sécurité
      run: |
        echo "🔒 Vérification de sécurité..."
        pip install safety bandit
        
        # Vérification des vulnérabilités dans les dépendances
        safety check --json || echo "⚠️ Vulnérabilités détectées, voir détails ci-dessus"
        
        # Analyse de sécurité du code
        bandit -r . -f json || echo "⚠️ Problèmes de sécurité détectés"

  build:
    runs-on: ubuntu-latest
    needs: tests
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: 🔽 Checkout du code
      uses: actions/checkout@v4
    
    - name: 🐳 Configuration Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: 🔐 Connexion au registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: 🏷️ Extraction métadonnées
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: 🔨 Build et push de l'image Docker
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
    
    - name: 🔍 Scan de sécurité de l'image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: 📤 Upload des résultats de sécurité
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    environment: staging
    
    steps:
    - name: 🔽 Checkout du code
      uses: actions/checkout@v4
    
    - name: 🚀 Déploiement sur Streamlit Cloud (Staging)
      run: |
        echo "🚀 Déploiement sur l'environnement de staging..."
        
        # Configuration pour Streamlit Cloud
        cat > .streamlit/config.toml << EOF
        [server]
        port = 8501
        enableCORS = false
        enableXsrfProtection = false
        
        [browser]
        gatherUsageStats = false
        
        [theme]
        primaryColor = "#2a5298"
        backgroundColor = "#ffffff"
        secondaryBackgroundColor = "#f0f2f6"
        textColor = "#262730"
        EOF
        
        echo "✅ Configuration Streamlit préparée"
        
        # Ici, en production, vous pourriez:
        # 1. Déployer sur Streamlit Cloud via API
        # 2. Déployer sur Heroku
        # 3. Déployer sur AWS/GCP/Azure
        # 4. Mettre à jour un cluster Kubernetes
        
        echo "📝 Simulation du déploiement staging réussie"
    
    - name: 🧪 Tests d'intégration staging
      run: |
        echo "🧪 Tests d'intégration sur staging..."
        
        # Attente que l'application soit disponible
        sleep 30
        
        python -c "
        import requests
        import time
        
        # URL de staging (à adapter selon votre plateforme)
        STAGING_URL = 'http://localhost:8501'  # Exemple
        
        # Test de disponibilité
        try:
            print('🔍 Test de disponibilité de l\'application...')
            # En production, tester l'URL réelle de staging
            print('✅ Application accessible (simulé)')
            
            # Tests API/endpoints si applicable
            print('🔗 Test des endpoints critiques...')
            print('✅ Endpoints répondent correctement (simulé)')
            
            print('🎉 Tests d\'intégration staging réussis')
            
        except Exception as e:
            print(f'❌ Erreur tests intégration: {e}')
            exit(1)
        "

  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    if: github.ref == 'refs/heads/main' && (github.event.inputs.environment == 'production' || github.event.inputs.force_deploy == true)
    environment: production
    
    steps:
    - name: 🔽 Checkout du code
      uses: actions/checkout@v4
    
    - name: 🛡️ Vérifications pré-déploiement
      run: |
        echo "🛡️ Vérifications pré-déploiement production..."
        
        # Vérification des variables d'environnement requises
        REQUIRED_SECRETS=("HOPSWORKS_API_KEY" "AQICN_API_KEY")
        
        for secret in "${REQUIRED_SECRETS[@]}"; do
            if [ -z "${!secret}" ]; then
                echo "❌ Variable manquante: $secret"
                exit 1
            else
                echo "✅ Variable configurée: $secret"
            fi
        done
        
        echo "✅ Toutes les vérifications passées"
      env:
        HOPSWORKS_API_KEY: ${{ secrets.HOPSWORKS_API_KEY }}
        AQICN_API_KEY: ${{ secrets.AQICN_API_KEY }}
    
    - name: 🚀 Déploiement en production
      run: |
        echo "🚀 Déploiement en production..."
        
        # Sauvegarde de la version actuelle
        echo "💾 Sauvegarde de la version précédente..."
        
        # Déploiement de la nouvelle version
        echo "🔄 Déploiement de la nouvelle version..."
        
        # Configuration production
        cat > .streamlit/config.toml << EOF
        [server]
        port = 8501
        enableCORS = false
        enableXsrfProtection = true
        
        [browser]
        gatherUsageStats = false
        
        [theme]
        primaryColor = "#2a5298"
        backgroundColor = "#ffffff"
        secondaryBackgroundColor = "#f0f2f6"
        textColor = "#262730"
        
        [logger]
        level = "warning"
        EOF
        
        echo "✅ Déploiement production simulé avec succès"
        
        # En production, ici vous pourriez:
        # - Déployer sur votre plateforme cloud
        # - Mettre à jour les DNS
        # - Activer la nouvelle version avec blue-green deployment
        # - Configurer le monitoring et les alertes
    
    - name: 🔍 Tests de fumée production
      run: |
        echo "🔍 Tests de fumée en production..."
        
        python -c "
        import time
        import requests
        
        print('⏳ Attente de la disponibilité de l\'application...')
        time.sleep(60)  # Attendre que l'app soit prête
        
        # URL de production (à adapter)
        PROD_URL = 'https://your-app.streamlit.app'  # Exemple
        
        try:
            print('🌐 Test de l\'URL de production...')
            # response = requests.get(PROD_URL, timeout=30)
            # assert response.status_code == 200
            print('✅ Application accessible en production (simulé)')
            
            print('📊 Test des fonctionnalités critiques...')
            # Ici, tester les endpoints/fonctionnalités critiques
            print('✅ Fonctionnalités critiques opérationnelles (simulé)')
            
            print('🎉 Déploiement production validé!')
            
        except Exception as e:
            print(f'❌ Erreur lors des tests de fumée: {e}')
            print('🚨 ROLLBACK REQUIS!')
            exit(1)
        "
    
    - name: 📊 Notification de déploiement
      if: always()
      run: |
        echo "📊 Génération du rapport de déploiement..."
        
        DEPLOY_STATUS="${{ job.status }}"
        COMMIT_SHA="${{ github.sha }}"
        BRANCH="${{ github.ref_name }}"
        ACTOR="${{ github.actor }}"
        
        echo "🚀 RAPPORT DE DÉPLOIEMENT"
        echo "========================"
        echo "📅 Date: $(date)"
        echo "👤 Déployé par: $ACTOR"
        echo "🌿 Branche: $BRANCH"
        echo "📝 Commit: $COMMIT_SHA"
        echo "🎯 Environnement: Production"
        echo "✅ Statut: $DEPLOY_STATUS"
        echo "🐳 Image: ${{ needs.build.outputs.image-tag }}"
        echo "========================"
        
        if [ "$DEPLOY_STATUS" == "success" ]; then
            MESSAGE="🎉 Déploiement production réussi!"
        else
            MESSAGE="🚨 Échec du déploiement production!"
        fi
        
        echo "$MESSAGE"
        
        # Notification Slack/Discord/Teams (exemple)
        # curl -X POST -H 'Content-type: application/json' \
        #   --data "{\"text\":\"$MESSAGE\"}" \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: 🧹 Nettoyage des artefacts
      run: |
        echo "🧹 Nettoyage des artefacts et images anciennes..."
        
        # Ici, vous pourriez nettoyer:
        # - Les anciennes images Docker
        # - Les artefacts de build
        # - Les caches obsolètes
        
        echo "✅ Nettoyage terminé"