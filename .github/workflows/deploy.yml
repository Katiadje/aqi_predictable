name: ðŸš€ Deploy - DÃ©ploiement Application AQI

on:
  push:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'pipelines/**'
      - 'requirements.txt'
      - 'Dockerfile'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement de dÃ©ploiement'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Forcer le dÃ©ploiement'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.9'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/aqi-predictor

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
    - name: ðŸ”½ Checkout du code
      uses: actions/checkout@v4
    
    - name: ðŸ Configuration Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ðŸ“¦ Installation des dÃ©pendances
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov flake8 black isort
    
    - name: ðŸ§¹ VÃ©rification du style de code
      run: |
        echo "ðŸ§¹ VÃ©rification du formatage avec Black..."
        black --check --diff . || echo "âš ï¸ Black: des fichiers nÃ©cessitent un formatage"
        
        echo "ðŸ“¦ VÃ©rification des imports avec isort..."
        isort --check-only --diff . || echo "âš ï¸ isort: des imports nÃ©cessitent un tri"
        
        echo "ðŸ” Analyse statique avec flake8..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: ðŸ§ª Tests unitaires
      run: |
        echo "ðŸ§ª ExÃ©cution des tests unitaires..."
        python -c "
        import sys
        import os
        
        # Ajout du chemin pour les imports
        sys.path.append('.')
        
        # Tests simples pour vÃ©rifier les imports et fonctions principales
        try:
            from app.utils.aqi_utils import AQIUtils, APIHelper, DataValidator
            from app.utils.plotting import AQIPlotter, DashboardComponents
            
            print('âœ… Import des utilitaires: OK')
            
            # Test des fonctions utilitaires
            aqi_category = AQIUtils.get_aqi_category(75)
            assert aqi_category == 'ModÃ©rÃ©', f'Erreur catÃ©gorie AQI: {aqi_category}'
            
            aqi_color = AQIUtils.get_aqi_color(75)
            assert aqi_color == '#FFFF00', f'Erreur couleur AQI: {aqi_color}'
            
            print('âœ… Tests AQI utils: OK')
            
            # Test de validation des donnÃ©es
            test_data = {'pm25': 25, 'pm10': 40, 'o3': 30, 'no2': 15}
            valid, errors = DataValidator.validate_pollutant_data(test_data)
            assert valid, f'Erreur validation: {errors}'
            
            print('âœ… Tests validation donnÃ©es: OK')
            
            print('ðŸŽ‰ Tous les tests passent!')
            
        except Exception as e:
            print(f'âŒ Erreur dans les tests: {e}')
            sys.exit(1)
        "
    
    - name: ðŸ”’ Tests de sÃ©curitÃ©
      run: |
        echo "ðŸ”’ VÃ©rification de sÃ©curitÃ©..."
        pip install safety bandit
        
        # VÃ©rification des vulnÃ©rabilitÃ©s dans les dÃ©pendances
        safety check --json || echo "âš ï¸ VulnÃ©rabilitÃ©s dÃ©tectÃ©es, voir dÃ©tails ci-dessus"
        
        # Analyse de sÃ©curitÃ© du code
        bandit -r . -f json || echo "âš ï¸ ProblÃ¨mes de sÃ©curitÃ© dÃ©tectÃ©s"

  build:
    runs-on: ubuntu-latest
    needs: tests
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: ðŸ”½ Checkout du code
      uses: actions/checkout@v4
    
    - name: ðŸ³ Configuration Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: ðŸ” Connexion au registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ðŸ·ï¸ Extraction mÃ©tadonnÃ©es
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: ðŸ”¨ Build et push de l'image Docker
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
    
    - name: ðŸ” Scan de sÃ©curitÃ© de l'image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: ðŸ“¤ Upload des rÃ©sultats de sÃ©curitÃ©
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    environment: staging
    
    steps:
    - name: ðŸ”½ Checkout du code
      uses: actions/checkout@v4
    
    - name: ðŸš€ DÃ©ploiement sur Streamlit Cloud (Staging)
      run: |
        echo "ðŸš€ DÃ©ploiement sur l'environnement de staging..."
        
        # Configuration pour Streamlit Cloud
        cat > .streamlit/config.toml << EOF
        [server]
        port = 8501
        enableCORS = false
        enableXsrfProtection = false
        
        [browser]
        gatherUsageStats = false
        
        [theme]
        primaryColor = "#2a5298"
        backgroundColor = "#ffffff"
        secondaryBackgroundColor = "#f0f2f6"
        textColor = "#262730"
        EOF
        
        echo "âœ… Configuration Streamlit prÃ©parÃ©e"
        
        # Ici, en production, vous pourriez:
        # 1. DÃ©ployer sur Streamlit Cloud via API
        # 2. DÃ©ployer sur Heroku
        # 3. DÃ©ployer sur AWS/GCP/Azure
        # 4. Mettre Ã  jour un cluster Kubernetes
        
        echo "ðŸ“ Simulation du dÃ©ploiement staging rÃ©ussie"
    
    - name: ðŸ§ª Tests d'intÃ©gration staging
      run: |
        echo "ðŸ§ª Tests d'intÃ©gration sur staging..."
        
        # Attente que l'application soit disponible
        sleep 30
        
        python -c "
        import requests
        import time
        
        # URL de staging (Ã  adapter selon votre plateforme)
        STAGING_URL = 'http://localhost:8501'  # Exemple
        
        # Test de disponibilitÃ©
        try:
            print('ðŸ” Test de disponibilitÃ© de l\'application...')
            # En production, tester l'URL rÃ©elle de staging
            print('âœ… Application accessible (simulÃ©)')
            
            # Tests API/endpoints si applicable
            print('ðŸ”— Test des endpoints critiques...')
            print('âœ… Endpoints rÃ©pondent correctement (simulÃ©)')
            
            print('ðŸŽ‰ Tests d\'intÃ©gration staging rÃ©ussis')
            
        except Exception as e:
            print(f'âŒ Erreur tests intÃ©gration: {e}')
            exit(1)
        "

  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    if: github.ref == 'refs/heads/main' && (github.event.inputs.environment == 'production' || github.event.inputs.force_deploy == true)
    environment: production
    
    steps:
    - name: ðŸ”½ Checkout du code
      uses: actions/checkout@v4
    
    - name: ðŸ›¡ï¸ VÃ©rifications prÃ©-dÃ©ploiement
      run: |
        echo "ðŸ›¡ï¸ VÃ©rifications prÃ©-dÃ©ploiement production..."
        
        # VÃ©rification des variables d'environnement requises
        REQUIRED_SECRETS=("HOPSWORKS_API_KEY" "AQICN_API_KEY")
        
        for secret in "${REQUIRED_SECRETS[@]}"; do
            if [ -z "${!secret}" ]; then
                echo "âŒ Variable manquante: $secret"
                exit 1
            else
                echo "âœ… Variable configurÃ©e: $secret"
            fi
        done
        
        echo "âœ… Toutes les vÃ©rifications passÃ©es"
      env:
        HOPSWORKS_API_KEY: ${{ secrets.HOPSWORKS_API_KEY }}
        AQICN_API_KEY: ${{ secrets.AQICN_API_KEY }}
    
    - name: ðŸš€ DÃ©ploiement en production
      run: |
        echo "ðŸš€ DÃ©ploiement en production..."
        
        # Sauvegarde de la version actuelle
        echo "ðŸ’¾ Sauvegarde de la version prÃ©cÃ©dente..."
        
        # DÃ©ploiement de la nouvelle version
        echo "ðŸ”„ DÃ©ploiement de la nouvelle version..."
        
        # Configuration production
        cat > .streamlit/config.toml << EOF
        [server]
        port = 8501
        enableCORS = false
        enableXsrfProtection = true
        
        [browser]
        gatherUsageStats = false
        
        [theme]
        primaryColor = "#2a5298"
        backgroundColor = "#ffffff"
        secondaryBackgroundColor = "#f0f2f6"
        textColor = "#262730"
        
        [logger]
        level = "warning"
        EOF
        
        echo "âœ… DÃ©ploiement production simulÃ© avec succÃ¨s"
        
        # En production, ici vous pourriez:
        # - DÃ©ployer sur votre plateforme cloud
        # - Mettre Ã  jour les DNS
        # - Activer la nouvelle version avec blue-green deployment
        # - Configurer le monitoring et les alertes
    
    - name: ðŸ” Tests de fumÃ©e production
      run: |
        echo "ðŸ” Tests de fumÃ©e en production..."
        
        python -c "
        import time
        import requests
        
        print('â³ Attente de la disponibilitÃ© de l\'application...')
        time.sleep(60)  # Attendre que l'app soit prÃªte
        
        # URL de production (Ã  adapter)
        PROD_URL = 'https://your-app.streamlit.app'  # Exemple
        
        try:
            print('ðŸŒ Test de l\'URL de production...')
            # response = requests.get(PROD_URL, timeout=30)
            # assert response.status_code == 200
            print('âœ… Application accessible en production (simulÃ©)')
            
            print('ðŸ“Š Test des fonctionnalitÃ©s critiques...')
            # Ici, tester les endpoints/fonctionnalitÃ©s critiques
            print('âœ… FonctionnalitÃ©s critiques opÃ©rationnelles (simulÃ©)')
            
            print('ðŸŽ‰ DÃ©ploiement production validÃ©!')
            
        except Exception as e:
            print(f'âŒ Erreur lors des tests de fumÃ©e: {e}')
            print('ðŸš¨ ROLLBACK REQUIS!')
            exit(1)
        "
    
    - name: ðŸ“Š Notification de dÃ©ploiement
      if: always()
      run: |
        echo "ðŸ“Š GÃ©nÃ©ration du rapport de dÃ©ploiement..."
        
        DEPLOY_STATUS="${{ job.status }}"
        COMMIT_SHA="${{ github.sha }}"
        BRANCH="${{ github.ref_name }}"
        ACTOR="${{ github.actor }}"
        
        echo "ðŸš€ RAPPORT DE DÃ‰PLOIEMENT"
        echo "========================"
        echo "ðŸ“… Date: $(date)"
        echo "ðŸ‘¤ DÃ©ployÃ© par: $ACTOR"
        echo "ðŸŒ¿ Branche: $BRANCH"
        echo "ðŸ“ Commit: $COMMIT_SHA"
        echo "ðŸŽ¯ Environnement: Production"
        echo "âœ… Statut: $DEPLOY_STATUS"
        echo "ðŸ³ Image: ${{ needs.build.outputs.image-tag }}"
        echo "========================"
        
        if [ "$DEPLOY_STATUS" == "success" ]; then
            MESSAGE="ðŸŽ‰ DÃ©ploiement production rÃ©ussi!"
        else
            MESSAGE="ðŸš¨ Ã‰chec du dÃ©ploiement production!"
        fi
        
        echo "$MESSAGE"
        
        # Notification Slack/Discord/Teams (exemple)
        # curl -X POST -H 'Content-type: application/json' \
        #   --data "{\"text\":\"$MESSAGE\"}" \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: ðŸ§¹ Nettoyage des artefacts
      run: |
        echo "ðŸ§¹ Nettoyage des artefacts et images anciennes..."
        
        # Ici, vous pourriez nettoyer:
        # - Les anciennes images Docker
        # - Les artefacts de build
        # - Les caches obsolÃ¨tes
        
        echo "âœ… Nettoyage terminÃ©"