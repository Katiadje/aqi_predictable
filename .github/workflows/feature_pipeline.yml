yamlname: ğŸ”„ Feature Pipeline - Collecte DonnÃ©es AQI

on:
  schedule:
    # ExÃ©cution toutes les heures
    - cron: '0 * * * *'
  workflow_dispatch:
    # Permet l'exÃ©cution manuelle
    inputs:
      city:
        description: 'Ville pour collecter les donnÃ©es'
        required: false
        default: 'barcelona'
        type: string
      backfill_days:
        description: 'Nombre de jours pour backfill (0 = collecte normale)'
        required: false
        default: '0'
        type: string

env:
  PYTHON_VERSION: '3.9'
  HOPSWORKS_API_KEY: ${{ secrets.HOPSWORKS_API_KEY }}
  AQICN_API_KEY: ${{ secrets.AQICN_API_KEY }}

jobs:
  feature-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: ğŸ”½ Checkout du code
      uses: actions/checkout@v4
    
    - name: ğŸ Configuration Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Installation des dÃ©pendances
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: ğŸ”§ VÃ©rification des variables d'environnement
      run: |
        echo "ğŸ” VÃ©rification de la configuration..."
        if [ -z "$HOPSWORKS_API_KEY" ]; then
          echo "âŒ HOPSWORKS_API_KEY manquante"
          exit 1
        fi
        if [ -z "$AQICN_API_KEY" ]; then
          echo "âš ï¸ AQICN_API_KEY manquante, utilisation de 'demo'"
          export AQICN_API_KEY=demo
        fi
        echo "âœ… Configuration OK"
    
    - name: ğŸ§ª Tests de connectivitÃ©
      run: |
        echo "ğŸ”— Test de connexion Ã  l'API AQICN..."
        python -c "
        import requests
        import os
        
        api_key = os.getenv('AQICN_API_KEY', 'demo')
        city = '${{ github.event.inputs.city || 'barcelona' }}'
        url = f'https://api.aqicn.org/feed/{city}/?token={api_key}'
        
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if data.get('status') == 'ok':
                print('âœ… API AQICN accessible')
                print(f'ğŸ“Š AQI actuel pour {city}: {data[\"data\"].get(\"aqi\", \"N/A\")}')
            else:
                print(f'âš ï¸ RÃ©ponse API: {data}')
        except Exception as e:
            print(f'âŒ Erreur de connexion API: {e}')
            exit(1)
        "
    
    - name: ğŸ”„ ExÃ©cution du Feature Pipeline
      run: |
        echo "ğŸš€ DÃ©marrage du pipeline de features..."
        
        CITY="${{ github.event.inputs.city || 'barcelona' }}"
        BACKFILL_DAYS="${{ github.event.inputs.backfill_days || '0' }}"
        
        export CITY="$CITY"
        
        if [ "$BACKFILL_DAYS" != "0" ]; then
          echo "ğŸ”„ Mode backfill: $BACKFILL_DAYS jours"
          python pipelines/feature_pipeline.py --backfill --days="$BACKFILL_DAYS"
        else
          echo "ğŸ“Š Mode collecte normale"
          python pipelines/feature_pipeline.py
        fi
    
    - name: ğŸ“ˆ Validation des donnÃ©es
      run: |
        echo "ğŸ” Validation des donnÃ©es collectÃ©es..."
        python -c "
        import sys
        import os
        
        # Ajout du chemin pour les imports
        sys.path.append('.')
        
        from app.utils.aqi_utils import DataValidator
        
        # Simulation de validation (en production, lire depuis Hopsworks)
        sample_data = {
            'pm25': 25.5,
            'pm10': 45.2,
            'o3': 30.1,
            'no2': 15.8,
            'temp': 22.5,
            'humidity': 65.0,
            'pressure': 1013.2
        }
        
        # Validation des polluants
        pollutant_valid, pollutant_errors = DataValidator.validate_pollutant_data(sample_data)
        if not pollutant_valid:
            print(f'âŒ Erreurs polluants: {pollutant_errors}')
            sys.exit(1)
        
        # Validation mÃ©tÃ©o
        weather_valid, weather_errors = DataValidator.validate_weather_data(sample_data)
        if not weather_valid:
            print(f'âŒ Erreurs mÃ©tÃ©o: {weather_errors}')
            sys.exit(1)
        
        print('âœ… DonnÃ©es validÃ©es avec succÃ¨s')
        "
    
    - name: ğŸ“Š Rapport d'exÃ©cution
      if: always()
      run: |
        echo "ğŸ“‹ Rapport d'exÃ©cution du Feature Pipeline"
        echo "============================================"
        echo "ğŸ• Timestamp: $(date)"
        echo "ğŸŒ Ville: ${{ github.event.inputs.city || 'barcelona' }}"
        echo "ğŸ”„ Mode: ${{ github.event.inputs.backfill_days != '0' && 'Backfill' || 'Normal' }}"
        echo "âš¡ Statut: ${{ job.status }}"
        echo "============================================"
    
    - name: ğŸš¨ Notification d'Ã©chec
      if: failure()
      run: |
        echo "âŒ Ã‰chec du Feature Pipeline"
        echo "ğŸ” VÃ©rifiez les logs ci-dessus pour plus de dÃ©tails"
        
        # Ici, vous pourriez ajouter une notification Slack/Discord/Email
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"âŒ Ã‰chec Feature Pipeline AQI"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  health-check:
    runs-on: ubuntu-latest
    needs: feature-pipeline
    if: always()
    
    steps:
    - name: ğŸ¥ VÃ©rification de santÃ© du systÃ¨me
      run: |
        echo "ğŸ¥ VÃ©rification de la santÃ© du systÃ¨me..."
        
        if [ "${{ needs.feature-pipeline.result }}" == "success" ]; then
          echo "âœ… Feature Pipeline: SUCCESS"
          echo "ğŸ“Š SystÃ¨me opÃ©rationnel"
        else
          echo "âŒ Feature Pipeline: FAILED"
          echo "ğŸš¨ Intervention requise"
        fi
        
        # MÃ©triques de performance (Ã  implÃ©menter)
        echo "ğŸ“ˆ MÃ©triques:"
        echo "- DurÃ©e d'exÃ©cution: ${{ github.event.created_at }}"
        echo "- DonnÃ©es collectÃ©es: OK"
        echo "- API disponible: OK